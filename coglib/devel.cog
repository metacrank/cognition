getd dup _ concat _ swap d i 
_quote_swap_quote_compose_swap_dup_d_i eval 
spc swap quote def
endl swap quote def

space 2 crank print unglue spc unglue 1 crank prepose def
newline 2 crank print unglue endl unglue 1 crank prepose def

ff 1 cut unaliasf 0 cut swap quote def

addon 2 crank unglue unglue compose unglue 1 crank compose def
push 2 crank quote unglue compose addon 1 crank def
curry 2 crank swap unglue quote addon prepose addon 1 crank def

4 crank crank* cranking
1 crank quote VMACRO cast
2 crank 5 push cut addon
1 crank def

# dup gets concat s dup getd concat d
2 crank geti unglue getd addon gets addon crankbase addon
f eval d f i endl s unglue
1 crank curry swap unglue prepose curry swap unglue prepose curry compose
2 crank drop unglue crank addon 1 push 0 push metacrank addon s addon d addon i addon
1 crank push
2 crank halt addon 1 push 1 push metacrank addon
1 crank def

# this is a comment
#demonstration of singlets in action!

# recursive factorial program: ( dup 0 > ( dup [ 9 ] + factorial * ) ( drop [ 1 ] ) if )
2 crank factorial nop
dup nop 0 push > compose
dup nop 9 push + compose factorial compose * compose VMACRO cast push eval
drop nop 1 push VMACRO cast
push eval if compose
1 crank VMACRO cast def

getargs size 1 >
2 crank 1 quote split compose swap compose drop compose 1 quote compose eval split compose drop compose
1 crank stack if
3 crank fact
1 crank =

2 crank 18 quote factorial compose . compose
1 crank stack if
